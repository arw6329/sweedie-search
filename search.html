<!DOCTYPE html>
<head>
    <title>sweedie word search</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        h1 {
            color: hotpink;
            text-align: center;
            font-family: 'Pacifico', cursive;
            font-weight: normal;
            letter-spacing: 0.072em;
        }

        main {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .left-column {
            display: flex;
            flex-direction: column;
        }

        .flex-fill-space {
            flex-grow: 1;
        }

        .cat-sprite {
            width: 300px;
            align-self: end;
        }

        .confetti {
            position: fixed;
            width: 20px;
            height: 30px;
            animation: rotate var(--spin-speed) linear infinite, fall var(--fall-speed) linear forwards;
            z-index: 2;
            --clr-opt-1: firebrick;
            --clr-opt-2: goldenrod;
            --clr-opt-3: yellow;
            --clr-opt-4: cornflowerblue;
            --clr-opt-5: rebeccapurple;
            --clr-opt-6: hotpink;
            --clr-opt-7: lightgreen;
        }

        .confetti.small {
            width: 3px;
            height: 10px;
        }

        @keyframes rotate {
            from {
                transform: rotate3d(var(--rand-rot-axis-x), var(--rand-rot-axis-y), var(--rand-rot-axis-z), 0deg);
            }

            to {
                transform: rotate3d(var(--rand-rot-axis-x), var(--rand-rot-axis-y), var(--rand-rot-axis-z), 360deg);
            }
        }

        @keyframes fall {
            from {
                top: calc(-10vh - var(--height-offset));
                left: var(--left-start);
            }

            to {
                top: 110vh;
                left: var(--left-end);
            }
        }

        @media only screen and (max-width: 768px) {
            body {
                margin: 0;
            }

            main {
                flex-direction: column;
                width: 100vw;
            }
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime&family=Merriweather&family=Open+Sans&family=Pacifico&display=swap" rel="stylesheet">
    <template id="word-search-puzzle-template">
        <style>
            :host {
                display: grid;
                --row-count: 0;
                --column-count: 0;
                grid-template-rows: repeat(var(--row-count), 1fr);
                grid-template-columns: repeat(var(--column-count), 1fr);
                gap: 1px;
                --border-color: #ffc3cd;
                background-color: var(--border-color);
                border: 2px solid var(--border-color);
                touch-action: none;
            }

            .cell {
                --row: 1;
                --column: 1;
                grid-row: calc(var(--row) + 1);
                grid-column: calc(var(--column) + 1);
                display: flex;
                justify-content: center;
                align-items: center;
                width: 35px;
                height: 35px;
                background-color: #fff1f4;
                font-family: 'Courier Prime', monospace;
                font-size: 1.3rem;
                color: #904250;
                user-select: none;
            }

            .cell.solved {
                color: #285528;
            }

            .cell span {
                z-index: 1;
            }

            .highlight-wrapper {
                --row-start: 1;
                --row-end: 1;
                --column-start: 1;
                --column-end: 1;
                grid-row: calc(var(--row-start) + 1) / calc(var(--row-end) + 2);
                grid-column: calc(var(--column-start) + 1) / calc(var(--column-end) + 2);
                display: flex;
                justify-content: center;
                align-items: center;
                pointer-events: none;
            }

            .highlight {
                --background-gradient-angle: 0deg;
                background: linear-gradient(var(--background-gradient-angle), #d47a89, #ffb1bd, #e7a5b0);
                background: pink;
                border-radius: 100px;
                border: 1px solid #9e7279;
                flex: 0 0 auto;
                opacity: 0.9;
            }

            .highlight.solved {
                background: #C1FFC1;
                border-color: #5D845D;
            }

            .highlight.spot {
                width: 28px;
                height: 28px;
            }

            .highlight.vertical {
                --background-gradient-angle: 90deg;
                width: 28px;
                height: 100%;
            }

            .highlight.horizontal {
                width: 100%;
                height: 28px;
            }

            .highlight:is(.diagonal-forwards, .diagonal-backwards) {
                --sqrt-2: 1.41421356237;
                --diag-length-buffer: 10px;
                width: calc(100% * var(--sqrt-2) - var(--diag-length-buffer));
                height: 24px;
            }

            .highlight.diagonal-forwards {
                transform: rotate(45deg);                
            }

            .highlight.diagonal-backwards {
                transform: rotate(-45deg);
            }

            @media only screen and (max-width: 768px) {
                :host {
                    --max-cell-width: calc((100vw - 2px * 2 - 1px * (var(--row-count) - 1)) / var(--row-count));
                }

                .cell {
                    width: var(--max-cell-width);
                    height: var(--max-cell-width);
                    font-size: 1rem;
                }

                .highlight.vertical {
                    width: calc(100vw / var(--row-count) - 4px);
                }

                .highlight.horizontal {
                    height: calc(100vw / var(--row-count) - 4px);
                }

                .highlight:is(.diagonal-forwards, .diagonal-backwards) {
                    height: calc(100vw / var(--row-count));
                }
            }
        </style>
    </template>
    <script type="module">
        import { register } from './js/custom-elements.js'

        register('word-search-puzzle', class extends HTMLElement {
            set dataRows(val) {
                this.style.setProperty('--row-count', val)
            }

            set dataColumns(val) {
                this.style.setProperty('--column-count', val)
            }

            // basically an enum
            static get Directions() {
                return {
                    RIGHT: 1,
                    LEFT: 2,
                    UP: 3,
                    DOWN: 4,
                    RIGHT_DOWN: 5,
                    RIGHT_UP: 6,
                    LEFT_DOWN: 7,
                    LEFT_UP: 8
                }
            }

            // speeds up fetchCell() by avoiding DOM operation
            #cellElemCache

            #words
            #solvedWords

            firstConnectedCallback() {
                this.template()

                this.#cellElemCache = []
                this.#words = []
                this.#solvedWords = new Set

                for(let row = 0; row < parseInt(this.dataset.rows); row++) {
                    this.#cellElemCache.push([])
                    for(let col = 0; col < parseInt(this.dataset.columns); col++) {
                        let cell = document.createElement('div')
                        cell.classList.add('cell')
                        cell.dataset.row = row
                        cell.dataset.column = col
                        cell.style.setProperty('--row', row)
                        cell.style.setProperty('--column', col)

                        let letter = document.createElement('span')
                        cell.appendChild(letter)

                        this.shadowRoot.appendChild(cell)
                    }
                }

                let currentDraggingHighlight = null
                let rowStart = 0
                let columnStart = 0
                let length = 0
                let direction = null
                this.queryAll('.cell').forEach(cell => {
                    cell.addEventListener('pointerdown', evt => {
                        rowStart = parseInt(cell.dataset.row)
                        columnStart = parseInt(cell.dataset.column)
                        currentDraggingHighlight = this.highlight(rowStart, columnStart, 1, null)
                    })

                    // pointermove fires for touch, pointerover doesn't work well
                    cell.addEventListener('pointermove', evt => {
                        if(!currentDraggingHighlight) {
                            return
                        }

                        let row = parseInt(cell.dataset.row)
                        let column = parseInt(cell.dataset.column)
                        
                        if(row === rowStart) {
                            this.highlight(
                                rowStart,
                                columnStart,
                                length = Math.abs(column - columnStart) + 1,
                                direction = column > columnStart
                                    ? this.constructor.Directions.RIGHT
                                : column < columnStart
                                    ? this.constructor.Directions.LEFT
                                    : null,
                                currentDraggingHighlight
                            )
                        } else if(column === columnStart) {
                            this.highlight(
                                rowStart,
                                columnStart,
                                length = Math.abs(row - rowStart) + 1,
                                direction = row > rowStart
                                    ? this.constructor.Directions.DOWN
                                    : this.constructor.Directions.UP,
                                currentDraggingHighlight
                            )
                        } else if(Math.abs(row - rowStart) === Math.abs(column - columnStart)) {
                            this.highlight(
                                rowStart,
                                columnStart,
                                length = Math.abs(row - rowStart) + 1,
                                direction = row > rowStart && column > columnStart
                                    ? this.constructor.Directions.RIGHT_DOWN
                                : row < rowStart && column < columnStart
                                    ? this.constructor.Directions.LEFT_UP
                                : row > rowStart && column < columnStart
                                    ? this.constructor.Directions.LEFT_DOWN
                                : this.constructor.Directions.RIGHT_UP,
                                currentDraggingHighlight
                            )
                        }
                    })
                })

                this.addEventListener('pointerup', evt => {
                    if(!currentDraggingHighlight) {
                        return
                    }

                    let highlightedSequence = this.fetchSequence(rowStart, columnStart, length, direction)
                    let highlightedWord = highlightedSequence.map(cell => cell.letter).join('')
                    let matchedWord = this.#words.find(word => word === highlightedWord || word.split('').reverse().join('') === highlightedWord)
                    if(matchedWord) {
                        currentDraggingHighlight.querySelector('.highlight').classList.add('solved')
                        highlightedSequence.forEach(cell => {
                            cell.elem.classList.add('solved')
                        })

                        this.#solvedWords.add(matchedWord)

                        this.dispatchEvent(new CustomEvent('solveword', {
                            detail: {
                                word: matchedWord
                            }
                        }))

                        if(this.#solvedWords.size === this.#words.length) {
                            this.dispatchEvent(new CustomEvent('solve'))
                        }
                    } else {
                        currentDraggingHighlight.remove()
                    }

                    currentDraggingHighlight = null
                })

                this.addEventListener('pointerleave', evt => {
                    currentDraggingHighlight?.remove()
                    currentDraggingHighlight = null
                })

                this.addEventListener('pointercancel', evt => {
                    currentDraggingHighlight?.remove()
                    currentDraggingHighlight = null
                })
            }

            populate(words) {
                this.#words = words

                // placing long words first increases odds that all can be placed successfully
                words.sort((a, b) => a.length < b.length).forEach(word => {
                    let candidates = [...this.#fetchCandidatePlacements(word)]
                    let placement = candidates[Math.floor(Math.random() * candidates.length)]
                    this.placeWord(word, placement.row, placement.column, placement.direction)
                    // this.highlight(placement.row, placement.column, word.length, placement.direction)
                })

                for(let row = 0; row < parseInt(this.dataset.rows); row++) {
                    for(let col = 0; col < parseInt(this.dataset.columns); col++) {
                        let cell = this.fetchCell(row, col)
                        if(cell.letter === null) {
                            cell.elem.firstElementChild.innerText = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'[Math.floor(Math.random() * 26)]
                        }
                    }
                }
            }

            fetchCell(row, column) {
                let elem = this.#cellElemCache[row][column]
                if(!elem) {
                    elem = this.query(`.cell[data-row="${row}"][data-column="${column}"]`)
                    this.#cellElemCache[row][column] = elem
                }

                return {
                    row: row,
                    column: column,
                    letter: elem.innerText || null,
                    elem: elem
                }
            }

            *#fetchCandidatePlacements(word) {
                for(let row = 0; row < parseInt(this.dataset.rows) - word.length + 1; row++) {
                    for(let col = 0; col < parseInt(this.dataset.columns) - word.length + 1; col++) {
                        for(const dir of this.validDirectionsFrom(row, col, word.length)) {
                            let currentSequence = this.fetchSequence(row, col, word.length, dir)
                            if(currentSequence.every((cell, i) => 
                                cell.letter === null || cell.letter === word[i]
                            )) {
                                yield {
                                    row: row,
                                    column: col,
                                    direction: dir
                                }
                            }
                        }
                    }
                }
            }

            validDirectionsFrom(row, column, length) {
                let directions = []

                let safeTop = row - length + 1 >= 0
                let safeBottom = row + length - 1 < parseInt(this.dataset.rows)
                let safeLeft = column - length + 1 >= 0
                let safeRight = column + length - 1 < parseInt(this.dataset.columns)

                if(safeRight) {
                    directions.push(this.constructor.Directions.RIGHT)

                    if(safeTop) {
                        directions.push(this.constructor.Directions.RIGHT_UP)
                    }

                    if(safeBottom) {
                        directions.push(this.constructor.Directions.RIGHT_DOWN)
                    }
                }

                if(safeLeft) {
                    directions.push(this.constructor.Directions.LEFT)

                    if(safeTop) {
                        directions.push(this.constructor.Directions.LEFT_UP)
                    }

                    if(safeBottom) {
                        directions.push(this.constructor.Directions.LEFT_DOWN)
                    }
                }

                if(safeTop) {
                    directions.push(this.constructor.Directions.UP)
                }

                if(safeBottom) {
                    directions.push(this.constructor.Directions.DOWN)
                }

                return directions
            }

            fetchSequence(row, column, length, direction) {
                let wordSearch = this
                let generator = function*(row, column, i) {
                    yield wordSearch.fetchCell(row, column)

                    if(i + 1 < length) {
                        switch(direction) {
                            case wordSearch.constructor.Directions.RIGHT:
                                yield* generator(row, column + 1, i + 1)
                                break
                            case wordSearch.constructor.Directions.LEFT:
                                yield* generator(row, column - 1, i + 1)
                                break
                            case wordSearch.constructor.Directions.UP:
                                yield* generator(row - 1, column, i + 1)
                                break
                            case wordSearch.constructor.Directions.DOWN:
                                yield* generator(row + 1, column, i + 1)
                                break
                            case wordSearch.constructor.Directions.RIGHT_DOWN:
                                yield* generator(row + 1, column + 1, i + 1)
                                break
                            case wordSearch.constructor.Directions.RIGHT_UP:
                                yield* generator(row - 1, column + 1, i + 1)
                                break
                            case wordSearch.constructor.Directions.LEFT_DOWN:
                                yield* generator(row + 1, column - 1, i + 1)
                                break
                            case wordSearch.constructor.Directions.LEFT_UP:
                                yield* generator(row - 1, column - 1, i + 1)
                                break
                            default:
                                throw new Error(`unrecognized direction ${direction}`)
                        }
                    }
                }

                return [...generator(row, column, 0)]
            }

            placeWord(word, row, column, direction) {
                this.fetchSequence(row, column, word.length, direction).forEach((cell, i) => {
                    cell.elem.querySelector('span').innerText = word[i]
                })
            }

            highlight(row, column, length, direction, existingWrapper = null) {
                let endRow
                let endColumn
                let directionClass
                switch(direction) {
                    case this.constructor.Directions.UP:
                        endRow = row - length + 1
                        endColumn = column
                        directionClass = 'vertical'
                        break
                    case this.constructor.Directions.DOWN:
                        endRow = row + length - 1
                        endColumn = column
                        directionClass = 'vertical'
                        break
                    case this.constructor.Directions.LEFT:
                        endRow = row
                        endColumn = column - length + 1
                        directionClass = 'horizontal'
                        break
                    case this.constructor.Directions.RIGHT:
                        endRow = row
                        endColumn = column + length - 1
                        directionClass = 'horizontal'
                        break
                    case this.constructor.Directions.RIGHT_UP:
                        endRow = row - length + 1
                        endColumn = column + length - 1
                        directionClass = 'diagonal-backwards'
                        break
                    case this.constructor.Directions.RIGHT_DOWN:
                        endRow = row + length - 1
                        endColumn = column + length - 1
                        directionClass = 'diagonal-forwards'
                        break
                    case this.constructor.Directions.LEFT_UP:
                        endRow = row - length + 1
                        endColumn = column - length + 1
                        directionClass = 'diagonal-forwards'
                        break
                    case this.constructor.Directions.LEFT_DOWN:
                        endRow = row + length - 1
                        endColumn = column - length + 1
                        directionClass = 'diagonal-backwards'
                        break
                    case null:
                        endRow = row
                        endColumn = column
                        directionClass = 'spot'
                        break
                    default:
                        throw new Error(`unrecognized direction ${direction}`)
                }

                let wrapper = existingWrapper ?? document.createElement('div')
                
                wrapper.style.setProperty('--row-start', Math.min(row, endRow))
                wrapper.style.setProperty('--row-end', Math.max(row, endRow))
                wrapper.style.setProperty('--column-start', Math.min(column, endColumn))
                wrapper.style.setProperty('--column-end', Math.max(column, endColumn))

                if(!existingWrapper) {
                    wrapper.classList.add('highlight-wrapper')

                    let highlight = document.createElement('div')
                    highlight.classList.add('highlight')

                    wrapper.appendChild(highlight)
                    this.shadowRoot.appendChild(wrapper)
                }

                wrapper.querySelector('.highlight').classList.remove('spot', 'horizontal', 'vertical', 'diagonal-forwards', 'diagonal-backwards')
                wrapper.querySelector('.highlight').classList.add(directionClass)

                return wrapper
            }
        })
    </script>
    <template id="word-search-bank-template">
        <style>
            :host {
                border: 1px solid gray;
                border-radius: 8px;
                display: flex;
                flex-direction: column;
            }

            h2 {
                text-align: center;
                border-bottom: 1px solid gray;
                background-color: #e7e7e7;
                padding: 10px;
                margin: 0;
                border-top-left-radius: inherit;
                border-top-right-radius: inherit;
                font-family: 'Merriweather', serif;
                font-weight: normal;
                font-size: 1.2rem;
                color: #676767;
            }

            .word-tray {
                display: grid;
                justify-items: center;
                grid-template-columns: 1fr 1fr 1fr;
                gap: 10px 30px;
                padding: 10px;
            }

            .word-wrapper {
                display: flex;
                justify-content: center;
                align-items: center;
                position: relative;
                padding: 0 10px;
                transform: scale(1);
                transition: transform 0.2s ease-out;
            }

            .word-wrapper.solved {
                transform: scale(0.9);
            }

            .word {
                font-family: 'Courier Prime', monospace;
                font-size: 1.1rem;
                display: flex;
                color: #222;
            }

            .word-wrapper.solved .word {
                color: #b2b2b2;
            }

            .strikethrough {
                position: absolute;
                height: 0.2rem;
                background-color: #007a00;
                width: 0;
                transition: width 0.3s ease-out;
                left: 0;
            }

            .word-wrapper.solved .strikethrough {
                width: 100%;
            }

            @media only screen and (max-width: 768px) {
                h2 {
                    font-size: 1.2rem;
                }

                .word-tray {
                    grid-template-columns: 1fr 1fr;
                }

                .word {
                    font-size: 1rem;
                }
            }
        </style>
        <h2>Word Bank</h2>
        <div class="word-tray"></div>
    </template>
    <script type="module">
        import { register } from './js/custom-elements.js'

        register('word-search-bank', class extends HTMLElement {
            firstConnectedCallback() {
                this.template()
            }

            populate(words) {
                words.forEach(word => {
                    let wrapper = document.createElement('div')
                    wrapper.classList.add('word-wrapper')

                    let span = document.createElement('span')
                    span.classList.add('word')
                    span.innerText = word

                    let strikethrough = document.createElement('div')
                    strikethrough.classList.add('strikethrough')

                    document.querySelector('word-search-puzzle').addEventListener('solveword', evt => {
                        if(evt.detail.word === word) {
                            wrapper.classList.add('solved')
                        }
                    })

                    wrapper.appendChild(span)
                    wrapper.appendChild(strikethrough)
                    this.query('.word-tray').appendChild(wrapper)
                })
            }
        })
    </script>
</head>
<body>
    <header>
        <h1>word search for sweedie</h1>
    </header>
    <main>
        <word-search-puzzle data-rows="20" data-columns="20"></word-search-puzzle>
        <div class="left-column">
            <word-search-bank></word-search-bank>
            <div class="flex-fill-space"></div>
            <img class="cat-sprite" src="/img/cats.png">
        </div>
        <script type="module">
            import { shuffle } from './js/array-shuffle.js'

            let wordlist = (await (await fetch('./wordlist.txt')).text()).split('\n').filter(word => word).map(word => word.toUpperCase())

            shuffle(wordlist)
            let selection = wordlist.slice(0, 15)

            document.querySelector('word-search-puzzle').populate(selection)
            document.querySelector('word-search-bank').populate(selection)

            document.querySelector('word-search-puzzle').addEventListener('solve', evt => {
                for(let i = 0; i < 200; i++) {
                    let confetti = document.createElement('div')
                    confetti.classList.add('confetti')

                    if(Math.random() > 0.4) {
                        confetti.classList.add('small')
                    }

                    let leftStart = Math.random() * 100
                    confetti.style.setProperty('--left-start', leftStart + 'vw')
                    confetti.style.setProperty('--left-end', leftStart + Math.random() * 10 - 5 + 'vw')

                    confetti.style.setProperty('--height-offset', Math.random() * 150 + 'px')

                    confetti.style.setProperty('--rand-rot-axis-x', Math.random() * 4 - 2)
                    confetti.style.setProperty('--rand-rot-axis-y', Math.random() * 4 - 2)
                    confetti.style.setProperty('--rand-rot-axis-z', Math.random() * 4 - 2)

                    confetti.style.setProperty('--spin-speed', Math.random() * 2 + 0.3 + 's')

                    confetti.style.setProperty('--fall-speed', Math.random() * 4 + 1 + 's')

                    confetti.style.backgroundColor = `var(--clr-opt-${Math.floor(Math.random() * 7) + 1})`

                    document.body.appendChild(confetti)
                }
            })
        </script>
    </main>
</body>
